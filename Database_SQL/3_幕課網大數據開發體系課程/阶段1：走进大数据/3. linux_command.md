# 第03章 Linux急速上手- Linux 高級命令   


### [1.1.3.1]3-1 文件相關的
1. vi: 文件編輯利器   
2. wc, uniq, sort, head: 文件內容統計   


* 編輯文件內容  
* 查找字符串   
* 查找某一行內容   
* 複製黏貼   
* 快速刪除   
* 快速跳到文件首行與末行



**1. 編輯文件內容**   
```linux
vi hello.txt  # get into the file   
i             # to insert some word to the file, get into command(editting) mode  
esc           # close the editting mode  
shift+:, wq   # write quit, 保存退出    

cat hello.txt
```

**2. 查找字符串**   


```linux  
#another file  
vi anaconda-ks.cfg  

# 快速查找"root password"
rootpw --is...
ctrl #查詢匹配
n    #next, 循環查找
i    #修改模式
wq

# 以行數快速查找
set nu

yy  #copy the row
p   #paste the row  
shift+:
dd  #delete the row
999dd  #delete below the row 
wq

G   #jump to the last row
gg  #jump to the first row
```

```linux

# close before saving the vi file
ls -a
.hello.txt.swp
rm -rf .hello.txt.swp
vi hello.txt

```

### [1.1.3.2]3-2~3-5 文件內容統計相關的
wc: 統計字數相關信息    
sort: 排序   
uniq: 檢查重複的行列   
head: 取前n條數據   

```linux

# wc

yy
p...
wc -c hello.txt  #count how many elements
wc -l hello.txt  #count how many rows


# sort

sort num.txt
sort -n num.txt  
sort -r num.txt  
sort -nr num.txt  

sort -k 2 -n num2.txt  #sort num with column 2



# uniq   
   
uniq hello.txt      #print重複行   
uniq -c hello.txt   #print重複行數量   
uniq -u hello.txt   #print不重複行   

sort test.txt | uniq #先排序再去蟲   



# ||   
head -3 num.txt   
sort -nr test.txt | head -3   #先排序再取前幾筆  
cat num.txt | sort -nr | head -3
```

### [1.1.3.6]3-6  與日期相關的 
date: 獲取當前時間

```linux   
date +"%Y-%m-%d %H:%M:%S"      
date +%s       #秒   
date +%s"000"  #毫秒   

date --date="2026-01-01 00:00:00"    
date --date="2026-01-01 00:00:00" +%s    
date --date="1 days ago" +%Y-%m-%d   

date --date="2-26-03-01 1 days ago" +%d   

```

### [1.1.3.7]3-7~3-8  與進程相關的 

ps: 顯示進程訊息
netstat: 顯示端口訊息    
jps: 顯示java進程訊息      
top: 動態監控進程訊息    
kill: 殺掉進程  

```linux   

ps -ef                #顯示系統內的所有進程  
ps -ef | grep python    
             

yum install -y net-tools
netstat -anp             #可查看端口訊息, 是否被占用
netstat -anp | grep 22   #ssh端口是否被開啟, 若有, 22可被監聽   

```


* jps: 類似ps命令, 不同的是ps是用來顯示所有進程信息的，而jps只顯示java進程信息。   
準確地說，jps是顯示當前用戶已啟動的java進程訊息, 包括進程號和簡短的進程command。         
* top: 主要作用在於"動態顯示"系統消耗資源最多的進程信息；包含進程ID, 內存占用, CPU占用等。    
和ps命令作用相同, 唯ㄧ區別是top命令能動態顯示進程訊息。    
* kill: 
- kill PID: 殺掉進程, 自殺 (相當於叉叉後)   
- kill -9 PID: 強制殺掉進程, 它殺 (但沒反應, 所以用工作管理員強制退出)   


### [1.1.3.9]3-9  Linux三劍客   
* grep: 查找, 常用於查找文件裡符合條件的字符串      
* sed: 編輯, 用來自動編輯一或多個文件, 簡化對文件的反覆操作      
* awk: 分析, 處理文本的語言, 強大的文本分析工具       
   
   
   
1. grep: 查找, 常用於查找文件裡符合條件的字符串      
grep: -i 忽略大小寫, -n 顯示該行的行號, -v 忽略包含指定字符串的內容      
注意: grep經常與 "|" 結合使用, 實現數據過濾查找   

ex. 
grep abc hello.txt   
cat hello.txt | grep abc   
grep -i ABC hello.txt  #忽略大小寫    
grep -n ABC hello.txt  #顯示該行的行號  

2. sed: 編輯, 用來自動編輯一或多個文件, 簡化對文件的反覆操作   
a/i 增加, d 刪除, s 替換, -i 直接修改源文件   

ex.   
sed '2a\haha' hello.txt  #在第2行下面加個haha   
此修改僅會修改緩衝區的文件, 不會修改源文件   
sed '1i\haha' hello.txt  #在第1行加個haha(insert)   
sed '$i\haha' hello.txt  #在最後一行加個haha
sed '7d' hello.txt  #刪除第7行   
sed '$d' hello.txt  #刪除最後一行   

sed 's/l/a/2' hello.txt  #每一行中的第2個'l', 替換成'a'    

sed [address] s/pattern/replacement/flags   
address: 表示指定要操作的具體行, 是一個可選項   
s: 表示替換操作    
pattern: 指的是需要替換的內容(原)    
replacement: 指的是要替換的新內容(新)    
flags: 有多種用法   
    第一種: 可以表示1~512間的任意值, 表示指定要替換的字符串，在這一行中出現第幾次時才進行替換。    
    第二種: 若以直接表示為g, 即替換每一行數據中所有匹配到的內容    
    第三種: 若為空, 則表示僅會在第一次匹配時作替換    

sed '2s/l/a/g' hello.txt  #第2行中的所有'l', 替換成'a'    
sed -i '2s/l/a/g' hello.txt  #直接修改源文件...    

sed -i '61s/aaasssdd/bbbdddcc/1' raids.con  #修改raids.con中, 第61行的 aaasssdd 改成 bbbdddcc    


3. awk: 分析, 處理文本的語言, 強大的文本分析工具

awk [option] programe file    
awk '{print $1}' hello.txt  #將每一行的第一列字串print出來   
awk '{print $0}' hello.txt  #將每一行的全部列字串print出來   

cat /etc/passwd   
':' 無法被解析   
awk -F: '{print $1}' /etc/passwd  #根據':'，將每一行的第一列字串print出來
awk '/world/{print $0}' hello.txt  #根據'world'，將每一行的全部字串print出來   
awk '($1 ~ /world/)/{print $0}' hello.txt  #根據第1列的'world'，將那一行的全部字串print出來  
awk '($2 ~ /world/)/{print $0}' hello.txt  #根據第2列的'world'，將那一行的全部字串print出來  

cat hello.txt | awk '($2 ~ /world/)/{print $0}' | wc -l   

